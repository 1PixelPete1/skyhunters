--!strict
-- LoomDesigner plugin prototype. The real Studio plugin would construct
-- UI elements but for tests we expose the core logic as plain functions.
-- This module manages a tiny state object representing the designer
-- selections and can export configs to a Lua file.

local GrowthVisualizer = require("growth/GrowthVisualizer")
local LoomConfigs = require("looms/LoomConfigs")

local LoomDesigner = {}

-- current working state used by the designer
local state = {
    configId = nil,
    baseSeed = 0,
    g = 0,
    overrides = {},
}

function LoomDesigner.Start(plugin)
    -- In Studio this would create the DockWidget and hook up events. For unit
    -- tests we simply record that the plugin started and return the state for
    -- inspection.
    print("LoomDesigner plugin started", plugin)
    return state
end

function LoomDesigner.SetConfigId(id)
    state.configId = id
end

function LoomDesigner.SetSeed(seed)
    state.baseSeed = seed
end

function LoomDesigner.RandomizeSeed()
    local rng = Random.new(os.clock())
    state.baseSeed = rng:NextInteger(1, 2^31 - 1)
    return state.baseSeed
end

function LoomDesigner.SetGrowthPercent(g)
    state.g = g
end

function LoomDesigner.SetOverrides(overrides)
    for k, v in pairs(overrides) do
        state.overrides[k] = v
    end
end

function LoomDesigner.RebuildPreview(container)
    if not state.configId then return end
    GrowthVisualizer.Render(container, {
        loomUid = 0, -- single preview loom
        configId = state.configId,
        baseSeed = state.baseSeed,
        g = state.g,
        overrides = state.overrides,
    })
end

-- Simple validation that checks for expected field types. Returns true if the
-- config appears valid otherwise false and the problematic field name.
function LoomDesigner.ValidateConfig(config)
    if type(config) ~= "table" then
        return false, "config"
    end
    if type(config.id) ~= "string" then
        return false, "id"
    end
    if config.growthDefaults and type(config.growthDefaults.segmentCount) ~= "number" then
        return false, "segmentCount"
    end
    return true
end

local function serialize(value, indent)
    indent = indent or 0
    local t = type(value)
    if t == "table" then
        local pieces = {"{"}
        local nextIndent = indent + 4
        for k, v in pairs(value) do
            local key
            if type(k) == "string" and k:match("^%a[%w_]*$") then
                key = k .. " = "
            else
                key = "[" .. serialize(k) .. "] = "
            end
            table.insert(pieces, string.rep(" ", nextIndent) .. key .. serialize(v, nextIndent) .. ",")
        end
        table.insert(pieces, string.rep(" ", indent) .. "}")
        return table.concat(pieces, "\n")
    elseif t == "string" then
        return string.format("%q", value)
    else
        return tostring(value)
    end
end

-- Export the provided config to disk. The default destination matches the
-- runtime path but tests may provide their own path to avoid mutating the repo.
function LoomDesigner.ExportConfig(config, destPath)
    local ok, err = LoomDesigner.ValidateConfig(config)
    if not ok then return false, err end
    destPath = destPath or "src/shared/looms/LoomConfigs.luau"

    local existing = {}
    local success, loaded = pcall(dofile, destPath)
    if success and type(loaded) == "table" then
        for k, v in pairs(loaded) do
            existing[k] = v
        end
    end
    existing[config.id] = config

    local file = assert(io.open(destPath, "w"))
    file:write("--!strict\n")
    file:write("-- Generated by LoomDesigner.ExportConfig\n\n")
    file:write("local configs = {\n")
    for k, v in pairs(existing) do
        file:write("    [" .. serialize(k) .. "] = " .. serialize(v, 4) .. ",\n")
    end
    file:write("}\n\nreturn configs\n")
    file:close()
    return true
end

return LoomDesigner
