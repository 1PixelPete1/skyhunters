# skyhunters
Generated by [Rojo](https://github.com/rojo-rbx/rojo) 7.5.1.

## Getting Started
To build the place from scratch, use:

```bash
rojo build -o "skyhunters.rbxlx"
```

Next, open `skyhunters.rbxlx` in Roblox Studio and start the Rojo server:

```bash
rojo serve
```

For more help, check out [the Rojo documentation](https://rojo.space/docs).

## Branching

Growth profiles can declare their own children. Each profile's `children` field is
an array of entries describing which profiles to spawn and how to place them.

```lua
profiles = {
  trunk = {
    kind = "curved",
    children = {
      { name = "branchA", count = 2, placement = "tip", rotation = "upright" },
      { name = "branchB", count = 1, placement = "junction", rotation = "inherit" },
    },
  },
  branchA = { kind = "zigzag" },
  branchB = { kind = "straight" },
}

branchAssignments = {
  trunkProfile = "trunk",
  branchCap = 2,
}
```

Each child entry specifies a profile `name`, spawn `count`, and optional `placement`
and `rotation`. The `GrowthVisualizer` walks this hierarchy, spawning branches
according to the rules of each parent profile.

### Depth progression

Branches track how far they are from the trunk using a `depth` counter. The
trunk starts at depth `0` and each child increases this depth by `1`.
`branchDepthMax` limits how deep the hierarchy can grow.

Profiles can provide different child rules for each depth by indexing the
`children` table with the parent's depth:

```lua
profiles = {
  trunk = {
    kind = "curved",
    children = {
      [0] = { -- depth 0 parents spawn branches at depth 1
        { name = "branchA", count = 2 },
      },
      [1] = { -- depth 1 parents spawn branches at depth 2
        { name = "branchB", count = 1 },
      },
    },
  },
  branchA = { kind = "zigzag" },
  branchB = { kind = "straight" },
}

branchAssignments = {
  trunkProfile = "trunk",
  branchCap = 2,
}
```

In this example, the trunk (depth 0) grows two `branchA` chains at depth 1.
Each `branchA` then follows the `[1]` rules, producing one `branchB` at depth 2.

### Module interplay and depth-based branching

`Main` holds authoring state for profiles and models while exposing helpers
such as `deepCopy`, `ensureTrunk`, and `applyAuthoring`. `UI.Build` surfaces
those controls to the plugin, and `ModelResolver` loads model assets during
authoring. The data flow looks like:

```
            UI.Build
                |
                v
   +------------------------------+
   |            Main              |
   | state.savedProfiles          |
   | state.branchAssignments      |
   | state.modelsByDepth          |
   | deepCopy()  ensureTrunk()    |
   | applyAuthoring()             |
   +------------------------------+
                |
                v
         ModelResolver
       ResolveOne()/ResolveFromList()

Branch tree (branchAssignments.trunkProfile):
depth 0: trunk
  └─ depth 1: branchA
      └─ depth 2: branchB
```

`branchDepthMax` caps how far the hierarchy grows. `ensureTrunk` keeps
`branchAssignments.trunkProfile` valid, `applyAuthoring` merges state with
configs using `deepCopy`, and `ModelResolver` pulls models for each depth.
