--!strict
-- WindGustsVolumetric.luau
-- Alternative volumetric wind gust system with varied storm effects

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local sharedRoot = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
local StormTypes = require(sharedRoot:WaitForChild("StormTypes"))
local StormDebugConfig = require(script.Parent.Parent:WaitForChild("StormDebugConfig"))

type StormState = StormTypes.StormState
type ConePose = StormTypes.ConePose
type ForbiddenAzimuth = StormTypes.ForbiddenAzimuth
export type PerfConfig = StormTypes.PerfConfig

-- Different gust particle types for variety
type GustType = "swirl" | "sheet" | "ribbon" | "cloud" | "vortex"

type VolumetricGust = {
    part: BasePart,
    mesh: SpecialMesh?,
    billboard: BillboardGui?,
    image: ImageLabel?,
    gustType: GustType,
    position: Vector3,
    velocity: Vector3,
    rotation: CFrame,
    rotationSpeed: Vector3,
    scale: Vector3,
    targetScale: Vector3,
    opacity: number,
    targetOpacity: number,
    lifetime: number,
    age: number,
    layer: number,
    turbulence: Vector3,
    active: boolean,
}

local GUST_TYPES: {GustType} = {"swirl", "sheet", "ribbon", "cloud", "vortex"}
local GUST_COLORS = {
    swirl = Color3.fromRGB(190, 200, 210),
    sheet = Color3.fromRGB(180, 190, 205),
    ribbon = Color3.fromRGB(185, 195, 210),
    cloud = Color3.fromRGB(175, 185, 200),
    vortex = Color3.fromRGB(195, 205, 215),
}

local WindGustsVolumetric = {}
WindGustsVolumetric.__index = WindGustsVolumetric

function WindGustsVolumetric.new(perfConfig: PerfConfig, perfTier: StormTypes.PerfTier?)
    local self = setmetatable({}, WindGustsVolumetric)
    self.PerfConfig = perfConfig
    self.PerfTier = perfTier or "HIGH"
    
    self.Container = Instance.new("Folder")
    self.Container.Name = "VolumetricWindGusts"
    self.Container.Parent = Workspace
    
    self.Random = Random.new(os.clock())
    self.Time = 0
    self.WindField = Vector3.new(0, 0, -1)
    
    -- Gust pools
    self.Gusts = {} :: {VolumetricGust}
    self.MaxGusts = perfConfig.gustsMax * 3 -- Triple for volumetric density
    
    self:InitializeGustPool()
    
    print("[VolumetricGusts] Initialized alternative gust system - adjust Storm_Gust* attributes")
    
    return self
end

function WindGustsVolumetric:InitializeGustPool()
    local config = StormDebugConfig:GetGustConfig()
    if not config then return end
    
    for i = 1, self.MaxGusts do
        local gustType = GUST_TYPES[self.Random:NextInteger(1, #GUST_TYPES)]
        local gust = self:CreateGust(i, gustType)
        table.insert(self.Gusts, gust)
    end
end

function WindGustsVolumetric:CreateGust(index: number, gustType: GustType): VolumetricGust
    local part = Instance.new("Part")
    part.Name = string.format("VolumetricGust_%s_%d", gustType, index)
    part.Anchored = true
    part.CanCollide = false
    part.CanQuery = false
    part.CanTouch = false
    part.Transparency = 0.3 -- Base transparency for 3D volume
    part.Material = Enum.Material.ForceField -- Volumetric material
    part.Color = GUST_COLORS[gustType]
    part.CastShadow = false
    part.Parent = self.Container
    
    local gust: VolumetricGust = {
        part = part,
        mesh = nil,
        billboard = nil,
        image = nil,
        gustType = gustType,
        position = Vector3.new(),
        velocity = Vector3.new(),
        rotation = CFrame.new(),
        rotationSpeed = Vector3.new(),
        scale = Vector3.one,
        targetScale = Vector3.one,
        opacity = 0,
        targetOpacity = 0,
        lifetime = 0,
        age = 0,
        layer = 1,
        turbulence = Vector3.new(),
        active = false,
    }
    
    -- Create type-specific visual elements
    if gustType == "swirl" then
        -- Swirling cylinder mesh
        local mesh = Instance.new("CylinderMesh")
        mesh.Parent = part
        gust.mesh = mesh
        part.Size = Vector3.new(15, 30, 15)
        
    elseif gustType == "sheet" then
        -- Wide flat sheet
        part.Size = Vector3.new(40, 0.5, 25)
        
    elseif gustType == "ribbon" then
        -- Long twisted ribbon
        part.Size = Vector3.new(3, 0.5, 60)
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.Brick
        mesh.Parent = part
        gust.mesh = mesh
        
    elseif gustType == "cloud" then
        -- Spherical cloud volume
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.Sphere
        mesh.Parent = part
        gust.mesh = mesh
        part.Size = Vector3.new(25, 20, 25)
        
    elseif gustType == "vortex" then
        -- Cone-shaped vortex
        local mesh = Instance.new("SpecialMesh")
        mesh.MeshType = Enum.MeshType.Wedge
        mesh.Parent = part
        gust.mesh = mesh
        part.Size = Vector3.new(20, 35, 20)
    end
    
    -- Add billboard texture overlay for detail
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "GustDetail"
    billboard.Adornee = part
    billboard.Size = UDim2.fromOffset(200, 200)
    billboard.LightInfluence = 0
    billboard.AlwaysOnTop = false
    billboard.MaxDistance = 300
    billboard.Parent = part
    
    local image = Instance.new("ImageLabel")
    image.Name = "DetailTexture"
    image.Size = UDim2.fromScale(1, 1)
    image.Position = UDim2.fromScale(0.5, 0.5)
    image.AnchorPoint = Vector2.new(0.5, 0.5)
    image.BackgroundTransparency = 1
    image.Image = "rbxasset://textures/particles/smoke_main.dds"
    image.ImageColor3 = GUST_COLORS[gustType]
    image.ImageTransparency = 0.5
    image.ScaleType = Enum.ScaleType.Stretch
    image.Parent = billboard
    
    gust.billboard = billboard
    gust.image = image
    
    return gust
end

function WindGustsVolumetric:SpawnGust(gust: VolumetricGust, cameraCf: CFrame, windDir: Vector3, config)
    local layer = self.Random:NextInteger(1, config.layerCount)
    gust.layer = layer
    
    -- Spawn position varies by layer
    local spawnDistance = 40 + layer * 30
    local lateralOffset = (self.Random:NextNumber() - 0.5) * spawnDistance
    local height = 10 + self.Random:NextNumber() * 30
    
    local spawnAngle = math.atan2(windDir.Z, windDir.X) + math.pi -- Behind wind direction
    local spawnOffset = Vector3.new(
        math.cos(spawnAngle) * spawnDistance + lateralOffset,
        height,
        math.sin(spawnAngle) * spawnDistance
    )
    
    gust.position = cameraCf.Position + spawnOffset
    
    -- Set velocity based on wind and gust type
    local baseSpeed = 30 + layer * 5
    gust.velocity = windDir * baseSpeed
    
    -- Type-specific spawn parameters
    if gust.gustType == "swirl" then
        gust.rotationSpeed = Vector3.new(0, 2, 0) -- Spin around Y axis
        gust.targetScale = Vector3.new(1 + self.Random:NextNumber(), 1, 1 + self.Random:NextNumber())
        gust.turbulence = Vector3.new(5, 0, 5)
        
    elseif gust.gustType == "sheet" then
        gust.rotationSpeed = Vector3.new(0.3, 0.1, 0) -- Slight tumble
        gust.targetScale = Vector3.new(1.5, 1, 1.2)
        gust.turbulence = Vector3.new(3, 8, 3)
        
    elseif gust.gustType == "ribbon" then
        gust.rotationSpeed = Vector3.new(0, 0.5, 1) -- Twist motion
        gust.targetScale = Vector3.new(0.8, 1, 1.5)
        gust.turbulence = Vector3.new(10, 2, 10)
        
    elseif gust.gustType == "cloud" then
        gust.rotationSpeed = Vector3.new(0.2, 0.3, 0.1) -- Slow tumble
        gust.targetScale = Vector3.new(1.3, 1.1, 1.3)
        gust.turbulence = Vector3.new(2, 1, 2)
        
    elseif gust.gustType == "vortex" then
        gust.rotationSpeed = Vector3.new(0, 3, 0) -- Fast spin
        gust.targetScale = Vector3.new(0.7, 1.4, 0.7)
        gust.turbulence = Vector3.new(7, -2, 7) -- Downdraft
    end
    
    -- Apply configuration scaling
    gust.targetScale *= config.scale
    gust.turbulence *= config.turbulence
    
    -- Set lifetime based on layer
    gust.lifetime = 3 + layer * 1.5 + self.Random:NextNumber() * 2
    gust.age = 0
    gust.active = true
    
    -- Initial state
    gust.scale = gust.targetScale * 0.1
    gust.opacity = 0
    gust.targetOpacity = 0.3 + (0.1 * (config.layerCount - layer + 1) / config.layerCount)
    gust.rotation = CFrame.fromEulerAnglesXYZ(
        self.Random:NextNumber() * math.pi * 2,
        self.Random:NextNumber() * math.pi * 2,
        self.Random:NextNumber() * math.pi * 2
    )
end

function WindGustsVolumetric:UpdateGust(gust: VolumetricGust, cameraCf: CFrame, windDir: Vector3, intensity: number, lanternEnabled: boolean, conePose: ConePose?, dt: number)
    if not gust.active then return end
    
    gust.age += dt
    
    -- Check lifetime
    if gust.age >= gust.lifetime then
        gust.active = false
        gust.part.Transparency = 1
        if gust.image then
            gust.image.ImageTransparency = 1
        end
        return
    end
    
    -- Update position with velocity and turbulence
    local turbulenceOffset = Vector3.new(
        math.sin(self.Time * 2 + gust.position.X * 0.1) * gust.turbulence.X,
        math.sin(self.Time * 1.5 + gust.position.Y * 0.1) * gust.turbulence.Y,
        math.cos(self.Time * 2 + gust.position.Z * 0.1) * gust.turbulence.Z
    )
    
    gust.position += (gust.velocity + turbulenceOffset) * dt
    
    -- Update rotation
    local rotationDelta = CFrame.fromEulerAnglesXYZ(
        gust.rotationSpeed.X * dt,
        gust.rotationSpeed.Y * dt,
        gust.rotationSpeed.Z * dt
    )
    gust.rotation = gust.rotation * rotationDelta
    
    -- Update scale (grow then shrink)
    local lifeProgress = gust.age / gust.lifetime
    local scaleFactor = math.sin(lifeProgress * math.pi) -- Peak at middle
    gust.scale = gust.scale:Lerp(gust.targetScale * (0.5 + scaleFactor), dt * 2)
    
    -- Apply transformations
    gust.part.CFrame = CFrame.new(gust.position) * gust.rotation
    gust.part.Size = Vector3.new(
        gust.part.Size.X * gust.scale.X,
        gust.part.Size.Y * gust.scale.Y,
        gust.part.Size.Z * gust.scale.Z
    )
    
    -- Update transparency
    local fadeIn = math.min(gust.age * 3, 1)
    local fadeOut = math.max(1 - (lifeProgress - 0.7) * 3.33, 0)
    local baseFade = fadeIn * fadeOut
    
    -- Distance-based fade
    local distToCamera = (gust.position - cameraCf.Position).Magnitude
    local distanceFade = math.clamp(1 - distToCamera / 250, 0, 1)
    
    -- Lantern cone effect
    local lanternFade = 1
    if lanternEnabled and conePose then
        local toGust = (gust.position - cameraCf.Position).Unit
        local dot = toGust:Dot(conePose.dir)
        local angleDeg = math.deg(math.acos(math.clamp(dot, -1, 1)))
        
        if angleDeg < conePose.halfAngleDeg * 1.5 then
            -- Dramatically reduce visibility in lantern cone
            lanternFade = 0.05 + (angleDeg / (conePose.halfAngleDeg * 1.5)) * 0.15
        end
    end
    
    -- Final opacity calculation
    local finalOpacity = gust.targetOpacity * baseFade * distanceFade * intensity * lanternFade
    gust.part.Transparency = 1 - math.clamp(finalOpacity * 0.7, 0, 0.9)
    
    if gust.image then
        gust.image.ImageTransparency = 1 - math.clamp(finalOpacity * 0.5, 0, 0.8)
    end
    
    -- Type-specific updates
    if gust.gustType == "swirl" and gust.mesh then
        -- Pulsing scale for swirls
        local pulse = 1 + math.sin(self.Time * 3 + gust.age) * 0.1
        gust.mesh.Scale = Vector3.new(pulse, 1, pulse)
        
    elseif gust.gustType == "vortex" then
        -- Increase rotation speed over time
        gust.rotationSpeed = gust.rotationSpeed * (1 + dt * 0.3)
    end
    
    -- Cull if too far or out of view
    if distToCamera > 300 then
        gust.active = false
        gust.part.Transparency = 1
        if gust.image then
            gust.image.ImageTransparency = 1
        end
    end
end

function WindGustsVolumetric:Update(state: StormState, conePose: ConePose?, forbidden: ForbiddenAzimuth?, lanternEnabled: boolean, dt: number?)
    -- DISABLED: This volumetric system causes ugly flickering with ForceField materials
    -- Use BlizzardSprites instead for proper weather effects
    return
    
    --[[
    local camera = Workspace.CurrentCamera
    if not camera then return end
    
    local config = StormDebugConfig:GetGustConfig()
    if not config or config.style ~= "volumetric" then return end
    
    local delta = dt or (1/60)
    self.Time += delta
    
    local cameraCf = camera.CFrame
    local windDir = state.vector.Magnitude > 0.01 and state.vector.Unit or Vector3.new(0.3, 0, -0.8).Unit
    local intensity = state.intensity * StormDebugConfig:GetGlobalIntensity()
    
    -- Update wind field for global effects
    self.WindField = self.WindField:Lerp(windDir, delta * 2)
    
    -- Spawn new gusts
    local spawnRate = intensity * 5 * delta -- Spawn rate per second
    if self.Random:NextNumber() < spawnRate then
        -- Find inactive gust to spawn
        for _, gust in ipairs(self.Gusts) do
            if not gust.active then
                self:SpawnGust(gust, cameraCf, windDir, config)
                
                -- Variation: Sometimes spawn multiple at once for burst effect
                if config.variation and self.Random:NextNumber() < 0.3 then
                    -- Find another inactive gust
                    for _, gust2 in ipairs(self.Gusts) do
                        if not gust2.active and gust2 ~= gust then
                            self:SpawnGust(gust2, cameraCf, windDir, config)
                            break
                        end
                    end
                end
                break
            end
        end
    end
    
    -- Update all active gusts
    for _, gust in ipairs(self.Gusts) do
        if gust.active then
            self:UpdateGust(gust, cameraCf, windDir, intensity, lanternEnabled, conePose, delta)
        end
    end
    --]]
end

function WindGustsVolumetric:Cleanup()
    for _, gust in ipairs(self.Gusts) do
        if gust.part then
            gust.part:Destroy()
        end
    end
    
    self.Gusts = {}
    
    if self.Container then
        self.Container:Destroy()
        self.Container = nil
    end
end

return WindGustsVolumetric
