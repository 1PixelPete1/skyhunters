--!strict
-- DistantWind.luau
-- Wide background wind sprites that sway and offset to imply distant storm motion
-- Enhanced to complement vignette gust system

local Workspace = game:GetService("Workspace")

local sharedRoot = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
local StormTypes = require(sharedRoot:WaitForChild("StormTypes"))
local StormConfig = require(sharedRoot:WaitForChild("StormConfig"))

type StormState = StormTypes.StormState
export type PerfConfig = StormTypes.PerfConfig

type WindSheet = {
    part: BasePart,
    billboard: BillboardGui,
    image: ImageLabel,
    angle: number,
    radius: number,
    height: number,
    swaySpeed: number,
    swayPhase: number,
    jitterSpeed: number,
    jitterPhase: number,
    baseWidth: number,
    baseHeight: number,
    zone: string, -- For tracking position relative to vignette
}

local config = StormConfig.DistantWind

local function studsToPixels(studs: number): number
    return math.floor(studs * 12)
end

local function clamp01(x: number): number
    return math.clamp(x, 0, 1)
end

-- ENHANCED: Zone classification for better visual layering
local function classifyZone(angleDeg: number): string
    local normalizedAngle = angleDeg % 360
    if (normalizedAngle >= 315 or normalizedAngle <= 45) then
        return "front"
    elseif (normalizedAngle >= 45 and normalizedAngle <= 135) then
        return "right"
    elseif (normalizedAngle >= 135 and normalizedAngle <= 225) then
        return "back"
    else
        return "left"
    end
end

local DistantWind = {}
DistantWind.__index = DistantWind

function DistantWind.new(perfConfig: PerfConfig, perfTier: StormTypes.PerfTier?)
    local self = setmetatable({}, DistantWind)
    self.PerfConfig = perfConfig
    self.PerfTier = perfTier or "HIGH"

    self.Container = Instance.new("Folder")
    self.Container.Name = "StormDistantWind"
    self.Container.Parent = Workspace

    self.Random = Random.new(os.clock())
    self.Sheets = {}

    for i = 1, perfConfig.distantSheets do
        local part = Instance.new("Part")
        part.Name = string.format("DistantWind_%d", i)
        part.Anchored = true
        part.CanCollide = false
        part.CanQuery = false
        part.CanTouch = false
        part.Transparency = 1
        part.Size = Vector3.new(0.2, 0.2, 0.2)
        part.Parent = self.Container

        local billboard = Instance.new("BillboardGui")
        billboard.Name = "WindBillboard"
        billboard.Adornee = part
        billboard.LightInfluence = 0
        billboard.MaxDistance = 900 -- ENHANCED: Increased for distant effect
        billboard.Size = UDim2.fromOffset(0, 0)
        billboard.AlwaysOnTop = false
        billboard.Parent = part

        local image = Instance.new("ImageLabel")
        image.Name = "Sprite"
        image.BackgroundTransparency = 1
        image.Size = UDim2.fromScale(1, 1)
        image.Image = config.texture
        image.ImageColor3 = Color3.fromRGB(215, 225, 245) -- ENHANCED: Slightly more blue for distant feel
        image.ImageTransparency = 1
        image.ScaleType = Enum.ScaleType.Stretch
        image.Parent = billboard

        local angle = self.Random:NextNumber() * math.pi * 2
        local angleDeg = math.deg(angle)
        local zone = classifyZone(angleDeg)
        
        local radius = config.radius + (self.Random:NextNumber() * 2 - 1) * (config.radiusJitter or 0)
        local height = config.heightRange[1] + self.Random:NextNumber() * (config.heightRange[2] - config.heightRange[1])
        local swaySpeed = config.swaySpeed[1] + self.Random:NextNumber() * (config.swaySpeed[2] - config.swaySpeed[1])
        local swayPhase = self.Random:NextNumber() * math.pi * 2
        local jitterSpeed = config.jitterSpeed[1] + self.Random:NextNumber() * (config.jitterSpeed[2] - config.jitterSpeed[1])
        local jitterPhase = self.Random:NextNumber() * math.pi * 2
        
        -- ENHANCED: Variable base sizes for more variety
        local baseWidth = config.widthRange[1] + self.Random:NextNumber() * (config.widthRange[2] - config.widthRange[1])
        local baseHeight = config.heightRange[1] + self.Random:NextNumber() * (config.heightRange[2] - config.heightRange[1])

        self.Sheets[i] = {
            part = part,
            billboard = billboard,
            image = image,
            angle = angle,
            radius = radius,
            height = height,
            swaySpeed = swaySpeed,
            swayPhase = swayPhase,
            jitterSpeed = jitterSpeed,
            jitterPhase = jitterPhase,
            baseWidth = baseWidth,
            baseHeight = baseHeight,
            zone = zone,
        }
    end

    return self
end

function DistantWind:Update(state: StormState, conePose, forbiddenAzimuth, lanternEnabled, dt: number?)
    local camera = Workspace.CurrentCamera
    if not camera then
        return
    end
    if #self.Sheets == 0 then
        return
    end

    local now = tick()
    local delta = (dt and dt > 0) and dt or 1 / 60
    local intensity = clamp01(state.intensity)

    local cameraCf = camera.CFrame
    local cameraPos = cameraCf.Position
    local right = cameraCf.RightVector
    local forward = cameraCf.LookVector
    local up = cameraCf.UpVector
    local jitterAmp = config.jitterAmplitude or { lateral = 0, vertical = 0 }
    
    -- FIXED: Use consistent wind direction from state (same as rain beams)
    local windDir = state.vector.Magnitude > 0.01 and state.vector.Unit or Vector3.new(0.2, 0, -0.8).Unit
    local windStrength = state.vector.Magnitude

    for _, sheet in ipairs(self.Sheets) do
        local horizontal = (right * math.cos(sheet.angle) + forward * math.sin(sheet.angle)) * sheet.radius
        local targetPos = cameraPos + horizontal + up * sheet.height
        local currentPos = sheet.part.Position
        if currentPos == Vector3.new() then
            currentPos = targetPos
        end

        local lerpAlpha = math.clamp(delta * config.followLerp * 10, 0, 1)
        local basePos = currentPos:Lerp(targetPos, lerpAlpha)

        -- FIXED: Jitter motion aligned with wind direction for consistency with rain beams
        local jitterPrimary = math.sin(now * sheet.jitterSpeed + sheet.jitterPhase)
        local jitterSecondary = math.cos(now * sheet.jitterSpeed * 0.7 + sheet.jitterPhase)
        
        -- Use wind direction for lateral movement instead of camera-relative
        local windRight = windDir:Cross(up).Unit
        local lateralOffset = (windRight * jitterPrimary + windDir * jitterSecondary * 0.3) * (jitterAmp.lateral or 0) * intensity
        local verticalOffset = up * jitterPrimary * (jitterAmp.vertical or 0)
        local renderPos = basePos + lateralOffset + verticalOffset
        
        -- FIXED: Orient sheets to face wind direction for better visual alignment
        local lookDirection = (cameraPos - renderPos).Unit
        sheet.part.CFrame = CFrame.lookAt(renderPos, renderPos + lookDirection, up)

        local sway = math.sin(now * sheet.swaySpeed + sheet.swayPhase)
        
        -- ENHANCED: Use base sizes with intensity and sway modulation
        local width = sheet.baseWidth * (0.8 + intensity * 0.4) * (1 + sway * 0.12)
        local height = sheet.baseHeight * (0.9 + intensity * 0.2) * (1 + sway * 0.08)
        
        -- ENHANCED: Zone-based size adjustments to complement vignette
        local zoneMultiplier = 1.0
        if sheet.zone == "back" then
            zoneMultiplier = 1.1 -- Slightly larger for distant background
        elseif sheet.zone == "front" then
            zoneMultiplier = 0.9 -- Smaller to not compete with foreground gusts
        end
        
        width = width * zoneMultiplier
        height = height * zoneMultiplier

        sheet.billboard.Size = UDim2.fromOffset(studsToPixels(width), studsToPixels(height))
        sheet.billboard.StudsOffsetWorldSpace = Vector3.new(0, height * 0.35 + verticalOffset.Y * 0.25, 0)

        -- ENHANCED: Zone-based alpha for better depth perception
        local baseAlpha = config.alpha
        if sheet.zone == "back" then
            baseAlpha = baseAlpha * 0.7 -- More transparent for depth
        elseif sheet.zone == "front" then
            baseAlpha = baseAlpha * 0.8 -- Slightly less transparent but still background
        end
        
        local alpha = intensity * baseAlpha * (1 + 0.15 * sway)
        sheet.image.ImageTransparency = 1 - math.clamp(alpha, 0, 0.6) -- ENHANCED: Cap at 0.6 to keep subtle
        
        -- ENHANCED: Subtle color variation based on zone
        local baseColor = Color3.fromRGB(215, 225, 245)
        if sheet.zone == "back" then
            baseColor = Color3.fromRGB(205, 215, 235) -- Slightly darker for distance
        end
        sheet.image.ImageColor3 = baseColor
    end
end

function DistantWind:Cleanup()
    for _, sheet in ipairs(self.Sheets) do
        if sheet.part then
            sheet.part:Destroy()
        end
    end
    self.Sheets = {}
    if self.Container then
        self.Container:Destroy()
        self.Container = nil
    end
end

return DistantWind
